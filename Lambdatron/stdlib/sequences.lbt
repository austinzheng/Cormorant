; Lambdatron standard library
; sequences.lbt (sequences)
; Parts of this code adapted from Clojure's standard library.

; Create a lazy sequence.
(defmacro lazy-seq [& body]
  (list '.lazy-seq (list* 'fn [] body)))

; Given a number of arguments, the last one being a list, create a list with the arguments followed by the list items.
(defn list*
  ([args] (seq args))
  ([a args] (cons a args))
  ([a b args] (cons a (cons b args)))
  ([a b c args] (cons a (cons b (cons c args))))
  ([a b c d & more]
  (cons a (cons b (cons c (cons d (spread more)))))))

; concat, as implemented by Clojure's stdlib
(defn concat
  ([] (lazy-seq nil))
  ([x] (lazy-seq x))
  ([x y]
    (lazy-seq
      (let [s (seq x)]
        (if s
          (cons (first s) (concat (rest s) y))
          y))))
  ([x y & zs]
    (let [cat (fn cat [xys zs]
                (lazy-seq
                  (let [xys (seq xys)]
                    (if xys
                      (cons (first xys) (cat (rest xys) zs))
                    (when zs
                      (cat (first zs) (next zs)))))))]
      (cat (concat x y) zs))))

; Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects.
(defn iterate
  [f x] (cons x (lazy-seq (iterate f (f x)))))

; Returns a lazy sequence of the first n items in coll, or all items if there are fewer than n.
(defn take
  [n coll]
    (lazy-seq
      (when (pos? n)
        (when-let [s (seq coll)]
          (cons (first s) (take (dec n) (rest s)))))))

; Returns a lazy, infinite sequence of repetitions of the items in coll.
(defn cycle
  [coll] (lazy-seq
    (when-let [s (seq coll)]
      (concat s (cycle s)))))

; Returns a lazy seq of the first item in each coll, then the second etc.
(defn interleave
  ([] ())
  ([c1] (lazy-seq c1))
  ([c1 c2]
    (lazy-seq
      (let [s1 (seq c1) s2 (seq c2)]
        (when (and s1 s2)
          (cons (first s1) (cons (first s2)
                                 (interleave (rest s1) (rest s2))))))))
  ([c1 c2 & colls]
    (lazy-seq
      (let [ss (map seq (conj colls c2 c1))]
        (when (every? identity ss)
          (concat (map first ss) (apply interleave (map rest ss))))))))

; Given a collection, return true iff (pred x) is logical true for every x in the collection.
(defn every? [pred coll]
  (cond
    (nil? (seq coll)) true
    (pred (first coll)) (recur pred (next coll))
    :else false))

; Given a function and a collection(s), create new collections by mapping all elements of the input collections.
; TODO: Replace the (fn [a]... with an inline function
(defn map
  ([f coll]
    (lazy-seq
      (when-let [s (seq coll)]
        (cons (f (first s)) (map f (rest s))))))
  ([f c1 c2]
    (lazy-seq
      (let [s1 (seq c1) s2 (seq c2)]
        (when (and s1 s2)
          (cons (f (first s1) (first s2))
            (map f (rest s1) (rest s2)))))))
  ([f c1 c2 c3]
    (lazy-seq
      (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]
        (when (and  s1 s2 s3)
          (cons (f (first s1) (first s2) (first s3))
            (map f (rest s1) (rest s2) (rest s3)))))))
  ([f c1 c2 c3 & colls]
    (let [step (fn step [cs]
                  (lazy-seq
                    (let [ss (map seq cs)]
                      (when (every? identity ss)
                        (cons (map first ss) (step (map rest ss)))))))]
            (map (fn [a] (apply f a)) (step (conj colls c3 c2 c1))))))

; Given a filter function and a collection, return a sequence consisting of all elements that pass the filter.
(defn filter
  ([pred]
    (fn [rf]
      (fn
        ([] (rf))
        ([result] (rf result))
        ([result input]
          (if (pred input)
            (rf result input)
            result)))))
  ([pred coll]
    (when-let [s (seq coll)]
    (let [f (first s) r (rest s)]
      (if (pred f)
        (cons f (filter pred r))
        (filter pred r)))
  )))
