//
//  lexer.swift
//  Lambdatron
//
//  Created by Austin Zheng on 11/12/14.
//  Copyright (c) 2014 Austin Zheng. All rights reserved.
//

import Foundation

/// Tokens representing special syntax characters.
enum SyntaxToken {
  case leftParentheses            // left parentheses '('
  case rightParentheses           // right parentheses ')'
  case leftSquareBracket          // left square bracket '['
  case rightSquareBracket         // right square bracket ']'
  case leftBrace                  // left brace '{'
  case rightBrace                 // right brace '}'
  case quote                      // single quote '''
  case backquote                  // isolate grave accent '`'
  case tilde                      // tilde '~'
  case tildeAt                    // tilde followed by at '~@'
  case at                         // at sign '@'
  case hashLeftBrace              // hash-left brace '#{'
  case hashQuote                  // hash-quote '#''
  case hashLeftParentheses        // hash-left parentheses '#('
  case hashUnderscore             // hash-underscore '#_'
}

/// Tokens that come out of the lex() function, intended as input to the parser.
enum LexToken {
  case syntax(SyntaxToken)
  case nilToken                   // nil
  case charLiteral(Character)     // character literal
  case stringLiteral(String)      // string (denoted by double quotes)
  case regexPattern(String)       // a pattern for a regular expression, denoted by #"SomeRegexPattern"
  case integer(Int)               // integer number
  case flPtNumber(Double)         // floating-point number
  case boolean(Bool)              // boolean (true or false)
  case keyword(String)            // keyword (prefixed by ':')
  case identifier(String)         // unknown identifier (function or variable name)
  case special(SpecialForm)       // a special form (e.g. 'quote')
  case builtInFunction(BuiltIn)   // a built-in function

  /// Return whether or not this LexToken is a specific syntax token.
  func isA(_ token: SyntaxToken) -> Bool {
    switch self {
    case let .syntax(s): return s == token
    default: return false
    }
  }
}

/// Lexer represents a collection of functions and static objects used to lex input strings into tokens. It is not
/// intended to be instantiated.
private struct Lexer {
  enum RawLexToken {
    case syntax(SyntaxToken)
    case charLiteral(Character)
    case stringLiteral(String)
    case regexPattern(String)
    case unknown(String)
  }

  // Character sets
  static let whitespace = NSCharacterSet.whitespacesAndNewlines()
  static let likeWhitespace = NSCharacterSet(charactersIn: ",")
  static let canFollowCharacter = NSCharacterSet(charactersIn: "\\()[]{}\"`@~")

  static let formatter = NumberFormatter()

  // TODO: get rid of this and replace with an extension
  /// Return whether or not the character is considered whitespace (and can be discarded) by the lexer.
  static func isWhitespace(char: Character) -> Bool {
    return character(char, isMemberOfSet: whitespace) || character(char, isMemberOfSet: likeWhitespace)
  }

  /// Perform the first phase of lexing. This takes in a string representing source code, and returns an array of
  /// RawLexTokens.
  static func lex1(string: String) -> ReadOptional<[RawLexToken]> {
    /// A list of tokens generated by the lex1 function.
    var rawTokenBuffer : [RawLexToken] = []
    /// The current position within the input string.
    let characters = string.characters
    var index = characters.startIndex
    // currentToken can only contain either a StringAtom or an Unknown token
    var currentToken : String = ""

    /// Helper function - flush the current-in-progress token to the token buffer and reset the in-progress token.
    func flushTokenToBuffer() {
      if !currentToken.isEmpty {
        rawTokenBuffer.append(.unknown(currentToken))
      }
      currentToken = ""
    }

    /// Helper function - flush the token, append a new one, and advance the index by one.
    func append(syntaxToken token: SyntaxToken) {
      if !currentToken.isEmpty {
        rawTokenBuffer.append(.unknown(currentToken))
      }
      currentToken = ""
      rawTokenBuffer.append(.syntax(token))
      characters.formIndex(after: &index)
    }

    var lastCharacterWasPartOfIdentifier : Bool = false
    while index < characters.endIndex {
      let character = characters[index]
      var thisCharacterWasPartOfIdentifier = false

      switch character {
      case ";":
        flushTokenToBuffer()                          // User starting a comment with a ;
        // Consume a comment
        consumeComment(in: characters, index: &index)
      case "\"":
        flushTokenToBuffer()                          // User starting a string with an opening "
        // Consume the string starting at the current position.
        switch consumeStringLiteral(in: characters, index: &index, raw: false) {
        case let .Just(string): rawTokenBuffer.append(.stringLiteral(string))
        case let .Error(error): return .Error(error)
        }
      case "(":
        append(syntaxToken: .leftParentheses)
      case ")":
        append(syntaxToken: .rightParentheses)
      case "[":
        append(syntaxToken: .leftSquareBracket)
      case "]":
        append(syntaxToken: .rightSquareBracket)
      case "{":
        append(syntaxToken: .leftBrace)
      case "}":
        append(syntaxToken: .rightBrace)
      case "'":
        append(syntaxToken: .quote)
      case "`":
        append(syntaxToken: .backquote)
      case "@":
        append(syntaxToken: .at)                        // @ without a leading tilde or other qualifier
      case "~":
        flushTokenToBuffer()                          // Tilde can either signify ~ or ~@
        let token = consumeTilde(in: characters, index: &index)
        rawTokenBuffer.append(.syntax(token))
      case "\\":
        flushTokenToBuffer()                          // Backslash represents a character literal
        switch consumeCharacter(in: characters, index: &index) {
        case let .Just(character): rawTokenBuffer.append(.charLiteral(character))
        case let .Error(error): return .Error(error)
        }
      case "#" where !lastCharacterWasPartOfIdentifier:
        // Note that when # is part of a symbol, it should not be treated as a dispatch macro
        flushTokenToBuffer()                          // Hash represents some sort of dispatch macro (#(, #', #"", etc)
        switch consumeHash(in: characters, index: &index) {
        case let .Just(token): rawTokenBuffer.append(token)
        case let .Error(error): return .Error(error)
        }
      case _ where isWhitespace(char: character):
        flushTokenToBuffer()                          // Whitespace/newline or equivalent (e.g. commas)
        characters.formIndex(after: &index)
      default:
        currentToken.append(character)                     // Any other valid character
        characters.formIndex(after: &index)
        thisCharacterWasPartOfIdentifier = true
      }

      // Update the 'identifier in progress' flag
      lastCharacterWasPartOfIdentifier = thisCharacterWasPartOfIdentifier
    }

    // If there's one last token left, flush it
    flushTokenToBuffer()
    // Return the buffer
    return .Just(rawTokenBuffer)
  }

  /// Perform the second phase of lexing, taking RawLexTokens and turning them into LexTokens. This may involve taking
  /// Unknown tokens and figuring out if they correspond to literals or other privileged forms.
  static func lex2(rawTokenBuffer: [RawLexToken]) -> ReadOptional<[LexToken]> {
    var tokenBuffer : [LexToken] = []
    for rawToken in rawTokenBuffer {
      switch rawToken {
      case let .syntax(s): tokenBuffer.append(.syntax(s))
      case let .charLiteral(c): tokenBuffer.append(.charLiteral(c))
      case let .stringLiteral(s): tokenBuffer.append(.stringLiteral(s))
      case let .regexPattern(s): tokenBuffer.append(.regexPattern(s))
      case let .unknown(unknown):
        // Figure out what to do with the token
        if let specialForm = SpecialForm(rawValue: unknown) {
          // Special form
          tokenBuffer.append(.special(specialForm))
        }
        else if let builtIn = BuiltIn(rawValue: unknown) {
          // Built-in function
          tokenBuffer.append(.builtInFunction(builtIn))
        }
        else if unknown == ":" {
          // This is an invalid keyword (no body).
          return .Error(ReadError(.KeywordParseFailureError))
        }
        else if unknown[unknown.startIndex] == ":" {
          // This is a keyword (starts with ":" and has at least one other character)
          tokenBuffer.append(.keyword(unknown[unknown.index(after: unknown.startIndex)..<unknown.endIndex]))
        }
        else if unknown == "nil" {
          // Literal nil
          tokenBuffer.append(.nilToken)
        }
        else if unknown == "false" {
          // Literal bool
          tokenBuffer.append(.boolean(false))
        }
        else if unknown == "true" {
          // Literal bool
          tokenBuffer.append(.boolean(true))
        }
        else if let numberToken = number(from: unknown) {
          // Literal number
          tokenBuffer.append(numberToken)
        }
        else {
          // Identifier
          tokenBuffer.append(.identifier(unknown))
        }
      }
    }
    return .Just(tokenBuffer)
  }

  /// Given a string representing an entire buffer, as well as an index representing a position in the buffer
  /// corresponding to the start of a comment, advance the index to the point after the comment ends.
  static func consumeComment(in str: String.CharacterView, index: inout String.Index) {
    var current = index

    while current < str.endIndex {
      let c = str[current]
      str.formIndex(after: &current)
      if character(c, isMemberOfSet: .newlines()) {
        // Character is a newline
        break
      }
    }
    // Found the newline, or reached the end of the entire buffer
    index = current
  }

  /// Given a string representing an entire buffer, as well as an index representing a position in the buffer
  /// corresponding to the start of a string literal, try to parse out the string. This function returns a string or nil
  /// if unsuccessful. Only if successful, it will also update the index position.
  static func consumeStringLiteral(in str: String.CharacterView, index: inout String.Index, raw: Bool) -> ReadOptional<String> {
    // Precondition: str[index] must be the double quote denoting the beginning of the string to consume.

    // Advance position to the first character in the string proper.
    var current = str.index(after: index)
    var buffer = ""

    while current < str.endIndex {
      let character = str[current]
      switch character {
      case "\"":
        // Reached the end of the string literal. Return it and update 'index'.
        index = str.index(after: current)
        return .Just(buffer)
      case "\\":
        if raw {
          // No special privileges for escape characters...
          fallthrough
        }
        // Found a control character. Consume the character following it.
        if current == str.indexOfLastCharacter {
          // An escape character cannot be the last character in the input
          return .Error(ReadError(.InvalidStringEscapeSequenceError))
        }
        if let escape = escapeCharacter(for: str[str.index(after: current)]) {
          // Append the escape character and skip two characters.
          buffer.append(escape)
          current = str.indexAdvancedTwice(after: current)
        }
        else {
          // The escape sequence was not valid.
          return .Error(ReadError(.InvalidStringEscapeSequenceError))
        }
      default:
        // Any other token is just skipped.
        buffer.append(character)
        str.formIndex(after: &current)
      }
    }
    // If we've gotten here we've reached the end of str, but without terminating our string literal.
    return .Error(ReadError(.NonTerminatedStringError))
  }

  /// Given a string and a start index, determine whether the token at the start index is '~' or '~@', returning a
  /// syntax token or error and updating the index appropriately.
  static func consumeTilde(in str: String.CharacterView, index: inout String.Index) -> SyntaxToken {
    // Precondition: str[index] must be '~'.
    if index == str.indexOfLastCharacter {
      // The '~' is at the end of the string.
      index = str.endIndex
      return .tilde
    }
    // We need to examine the following character.
    let next = str.character(after: index)
    if next == "@" {
      index = str.indexAdvancedTwice(after: index)
      return .tildeAt
    }
    else {
      index = str.index(after: index)
      return .tilde
    }
  }

  /// Given a string and a start index which points to a '#' in the string, determine the proper dispatch macro the '#'
  /// corresponds to and build it, updating the index appropriately.
  static func consumeHash(in str: String.CharacterView, index: inout String.Index) -> ReadOptional<RawLexToken> {
    // Precondition: str[index] must be '#'.
    if index == str.indexOfLastCharacter {
      // The '#' is at the end of the string (this is invalid)
      return .Error(ReadError(.InvalidDispatchMacroError))
    }
    // Examine the character that comes after the '#'
    let this = str.character(after: index)
    switch this {
    case "{":           // Set start marker
      index = str.indexAdvancedTwice(after: index)
      return .Just(.syntax(.hashLeftBrace))
    case "\"":          // Regex pattern
      index = str.index(after: index)
      return consumeStringLiteral(in: str, index: &index, raw: true).then { .Just(.regexPattern($0)) }
    case "'":           // Var-quote
      index = str.indexAdvancedTwice(after: index)
      return .Just(.syntax(.hashQuote))
    case "(":           // Inline function start
      index = str.indexAdvancedTwice(after: index)
      return .Just(.syntax(.hashLeftParentheses))
    case "_":           // Ignore next form
      index = str.indexAdvancedTwice(after: index)
      return .Just(.syntax(.hashUnderscore))
    default:
      return .Error(ReadError(.InvalidDispatchMacroError))
    }
  }

  /// Given a string and a start index, return the character described by the character literal at that position, or
  /// nil, and update the index appropriately.
  static func consumeCharacter(in str: String.CharacterView, index: inout String.Index) -> ReadOptional<Character> {
    // Precondition: str[index] is the "\" character that begins the character literal.
    if index == str.indexOfLastCharacter {
      // No character literals can start at the very end of the string.
      return .Error(ReadError(.InvalidCharacterError))
    }

    let start = str.index(after: index)
    // The first character in the character literal
    let firstCharacter = str[start]
    // The index of the character following the first character in the character literal expression
    let followingIndex = str.index(after: start)

    if followingIndex == str.endIndex || characterTerminatesLiteral(str[followingIndex]) {
      // Single-character literal
      index = followingIndex
      return .Just(firstCharacter)
    }
    if firstCharacter == "u"  {
      // Possible unicode character literal
      var thisIndex = str.index(after: start)
      if let d0 = digitAsNumber(str, &thisIndex, .Hexadecimal),
        d1 = digitAsNumber(str, &thisIndex, .Hexadecimal),
        d2 = digitAsNumber(str, &thisIndex, .Hexadecimal),
        d3 = digitAsNumber(str, &thisIndex, .Hexadecimal)
        where thisIndex == str.endIndex || characterTerminatesLiteral(str[thisIndex]) {
          index = thisIndex
          let value : Int = 4096*d0 + 256*d1 + 16*d2 + d3
          return .Just(Character(UnicodeScalar(value)))
      }
      // Note that there are no named characters whose names begin with 'u', so this is acceptable.
      return .Error(ReadError(.InvalidUnicodeError))
    }
    if firstCharacter == "o" {
      // Possible octal character literal
      var thisIndex = str.index(after: start)
      if let d0 = digitAsNumber(str, &thisIndex, .Octal),
        d1 = digitAsNumber(str, &thisIndex, .Octal),
        d2 = digitAsNumber(str, &thisIndex, .Octal)
        where thisIndex == str.endIndex || characterTerminatesLiteral(str[thisIndex]) {
          index = thisIndex
          let value : Int = 64*d0 + 8*d1 + d2
          if value < 256 { return .Just(Character(UnicodeScalar(value))) }
      }
      // Note that there are no named characters whose names begin with 'o', so this is acceptable.
      return .Error(ReadError(.InvalidOctalError))
    }

    // At this point, the character is either a named character or invalid.
    // Find the end of the character.
    var current = followingIndex
    while current < str.endIndex {
      str.formIndex(after: &current)
      if current == str.endIndex || characterTerminatesLiteral(str[current]) {
        break
      }
    }
    // Switch on the name of the character.
    index = current
    switch String(str[start..<current]) {
    case "space": return .Just(" ")
    case "tab": return .Just("\t")
    case "newline": return .Just("\n")
    case "return": return .Just("\r")
    case "backspace": return .Just(Character(UnicodeScalar(8)))
    case "formfeed": return .Just(Character(UnicodeScalar(12)))
    default:
      // Reset index
      index = str.index(before: start)
      return .Error(ReadError(.InvalidCharacterError))
    }
  }

  /// Return whether or not a character immediately following a character literal can mark the beginning of the next
  /// token to be lexed.
  static func characterTerminatesLiteral(_ c: Character) -> Bool {
    // A character can be adjacent to:
    // * Another character (e.g. \a\a)
    // * The start or end of a list (e.g. (\a))
    // * The start or end of a vector (e.g. \a[])
    // * The start or end of a bracketed form (e.g. \a{})
    // * The start of a string (e.g. \a"hello")
    // * The macro symbols `, @, or ~
    // A character cannot touch a keyword (:), literal quote ('), hash (#), number, true, false, or nil.
    return character(c, isMemberOfSet: whitespace) || character(c, isMemberOfSet: canFollowCharacter)
  }

  /// Return a LexToken representing a number type if the input string can be converted into a number, or nil otherwise.
  static func number(from str: String) -> LexToken? {
    enum NumberMode { case Integer, FloatingPoint }
    var mode : NumberMode = .Integer

    // Scan string for "."
    for item in str.characters {
      if item == "." {
        switch mode {
        case .Integer:
          mode = .FloatingPoint
        case .FloatingPoint:
          // A second decimal point makes the number invalid
          return nil
        }
      }
    }

    // The classic 'isNumber()' function.
    switch mode {
    case .Integer:
      if let number = Int(str) {
        return .integer(number)
      } else {
        return nil
      }
    case .FloatingPoint:
      if let number = Double(str) {
        return .flPtNumber(number)
      } else {
        return nil
      }
    }
  }
}

/// Given a raw input (as a string), lex it into individual tokens.
func lex(_ raw: String) -> ReadOptional<[LexToken]> {
  return Lexer.lex1(string: raw).then { Lexer.lex2(rawTokenBuffer: $0) }
}

/// Given the second character in a two-character escape sequence (e.g. "n" in "\n"), return the character the escape
/// sequence corresponds to (if one exists).
private func escapeCharacter(for sequence: Character) -> Character? {
  switch sequence {
  case "r": return "\r"
  case "n": return "\n"
  case "t": return "\t"
  case "\"": return "\""
  case "\\": return "\\"
  default: return nil
  }
}

private enum NumberType { case Decimal, Octal, Hexadecimal }

/// Given a string, an index within the string, and a type of number, return the numeric value of the character at the
/// index, or nil if the index is invalid or the character is not a valid digit for the number type. This function
/// will advance the index as long as the index isn't past the end of the string.
private func digitAsNumber(_ string: String.CharacterView, _ idx: inout String.Index, _ type: NumberType) -> Int? {
  if idx >= string.endIndex { return nil }
  var value : Int? = nil
  switch string[idx] {
  case "0": value = 0
  case "1": value = 1
  case "2": value = 2
  case "3": value = 3
  case "4": value = 4
  case "5": value = 5
  case "6": value = 6
  case "7": value = 7
  case "8" where type == .Decimal || type == .Hexadecimal: value = 8
  case "9" where type == .Decimal || type == .Hexadecimal: value = 9
  case "a" where type == .Hexadecimal, "A" where type == .Hexadecimal: value = 10
  case "b" where type == .Hexadecimal, "B" where type == .Hexadecimal: value = 11
  case "c" where type == .Hexadecimal, "C" where type == .Hexadecimal: value = 12
  case "d" where type == .Hexadecimal, "D" where type == .Hexadecimal: value = 13
  case "e" where type == .Hexadecimal, "E" where type == .Hexadecimal: value = 14
  case "f" where type == .Hexadecimal, "F" where type == .Hexadecimal: value = 15
  default: break
  }
  idx = string.index(after: idx)
  return value
}
